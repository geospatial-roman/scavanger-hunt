<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Scavenger Hunt</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />

  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #map {
      width: 100vw;
      height: 100vh;
    }
    .hint-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      z-index: 9999;
      max-width: 90vw;
      padding: 1.2rem 1.4rem 1rem;
      display: none;
    }
    .hint-popup h2 {
      margin: 0 0 .5rem;
      font-size: 1.25rem;
    }
    .hint-popup p {
      margin: 0 0 1rem;
    }
    .hint-popup button {
      border: none;
      background: #2563eb;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 9999px;
      font-weight: 600;
      cursor: pointer;
    }
    .status-bar {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.55);
      color: #fff;
      padding: .4rem .8rem;
      border-radius: 9999px;
      font-size: .8rem;
      z-index: 5000;
    }
    .show-zone-btn {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 5001;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: .5rem .8rem;
      font-size: .8rem;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    }
    .progress-wrap {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: min(400px, 80vw);
      background: rgba(0,0,0,0.15);
      border-radius: 9999px;
      overflow: hidden;
      height: 10px;
      z-index: 5000;
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #2563eb, #38bdf8);
      transition: width .3s ease;
    }
    /* Move and style the base layer control */
    .leaflet-control-layers {
      margin-bottom: 50px !important;  /* ðŸŸ¢ space above the progress bar */
      margin-right: 15px !important;   /* spacing from right edge */
      border-radius: 10px !important;
      box-shadow: 0 4px 10px rgba(0,0,0,0.25) !important;
      background: rgba(255, 255, 255, 0.9) !important;
      font-size: 0.85rem !important;
    }

    .leaflet-control-layers-list {
      padding: 8px 10px !important;
    }

    .leaflet-control-layers-toggle {
      width: 36px !important;
      height: 36px !important;
      background-size: 20px 20px !important;
      border-radius: 8px !important;
    }

  </style>
</head>
<body>
  <div id="map"></div>

  <div class="status-bar" id="status">Waiting for locationâ€¦</div>
  <div class="progress-wrap">
    <div class="progress-bar" id="progressBar"></div>
  </div>
  <button class="show-zone-btn" id="toggleZoneBtn" onclick="toggleNextZone()">Show next zone</button>

  <!-- Hint modal -->
  <div class="hint-popup" id="hintBox">
    <h2 id="hintTitle">Hint</h2>
    <p id="hintText"></p>
    <button onclick="closeHint()">Got it!</button>
  </div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    crossorigin=""
  ></script>
  <script>
    const LOCATIONS = [
  {
    name: "Start HG",
    lat: 48.15615305668851,
    lng: 11.588767033927423,
    radius: 40,
    hint: "Euer erstes Ziel: Hier trafen sich in der Geschichte schon viele Hausangestellte vor der Arbeit um zu tanzen. Ihr trefft euch hier um euch an warmen Tassen zu wÃ¤rmen.",
  },
  {
    name: "Stop 1",
    lat: 48.15260840964887,
    lng: 11.592070503257368,
    radius: 60,
    hint: `Wenn eure Tassen geleert sind, folgt diesem Reim:
            Hier tobt sonst wild die kalte Flut,
            ein TÃ¤nzeln, Toben â€“ Lebensgut.
            Doch nun verstummt das Wasserlein,
            und MÃ¼nchens Welle schlÃ¤ft allein.`
  },
  {
    name: "Stop 2",
    lat: 48.143444904588485,
    lng: 11.58772264788510,
    radius: 40,
    hint: "Wenn die letzte Boulekugel geworfen und der letzte Apperol ausgeschenkt ist, wird unter dieser Kuppel aus dem Jahr 1616, jeden sommerlichen Abend das Tanzbein geschwungen.",
  },
  {
    name: "Stop 3",
    lat: 48.142935842127585,
    lng: 11.580050283393602,
    radius: 30,
    hint: "Auf diesem Platz kann man in stillen NÃ¤chten MÃ¼nchens versteckten Fluss, in weniger stillen, den PfÃ¤lzer Wein flieÃŸen hÃ¶ren.",
  },
    {
    name: "Stop 4",
    lat: 48.142062325451676,
    lng: 11.57751016696055,
    radius: 50,
    hint: "Sucht den richtigen, runden Gullideckel in der Mitte des Platzes und lauscht dem Unterirdischen Fluss rauschen.",
  },
  {
    name: "Stop 4",
    lat: 48.142062325451676,
    lng: 11.57751016696055,
    radius: 50,
    hint: "NÃ¤chster Stop: WÃ¤rmt euch unter dem wachsamen Blick von KurfÃ¼rst Maximilian I. von Bayern bei einem weiteren TÃ¤sschen auf.",
  },
  {
    name: "Stop 5",
    lat: 48.14332920900223,
    lng: 11.576131742199184,
    radius: 40,
    hint: "In diesem Wirthaus kann man direkt in der KÃ¼che eine Taxisemmel bestellen und wird nicht von der Bedienung verjagt.",
  },
  {
    name: "Stop 6",
    lat: 48.13989862652583,
    lng: 11.577387310704061,
    radius: 40,
    hint: "Hier, vor der lieben Frau, sitzen MÃ¶nche und genieÃŸen goldenes GebrÃ¤u der Ã¤ltesten Brauerei MÃ¼nchens.",
  },
  {
    name: "Stop 7",
    lat: 48.13858335211532,
    lng: 11.572168352693478,
    radius: 40,
    hint: "GlÃ¼ckwunsch, ihr seid da!",
  },
];


    // read saved progress (this is the "next" stop index)
    let saved = localStorage.getItem("huntProgress");
    let currentIndex = isNaN(parseInt(saved, 10)) ? 0 : parseInt(saved, 10);

    const map = L.map("map").setView([LOCATIONS[0].lat, LOCATIONS[0].lng], 17);


    // basemaps
    const baseLayers = {
      "OpenStreetMap": L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: '&copy; OpenStreetMap contributors'
      }),
      "Satellite (ESRI)": L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
        attribution: '&copy; <a href="https://www.esri.com/">Esri</a>, Earthstar Geographics'
      }),
      "Topographic": L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", {
        attribution: 'Map data: &copy; <a href="https://opentopomap.org">OpenTopoMap</a>'
      }),
      "Dark Mode": L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
        attribution: '&copy; <a href="https://carto.com/">CARTO</a>'
      })
    };
    baseLayers["OpenStreetMap"].addTo(map);
    L.control.layers(baseLayers, null, { position: 'bottomright' }).addTo(map);


    // Custom Santa icon
    const santaIcon = L.icon({
      iconUrl: 'santa.png',  // path to your image
      iconSize: [60, 60],    // adjust size to fit nicely on map
      iconAnchor: [30, 60],  // point of the icon that corresponds to the marker's location
      popupAnchor: [0, -60], // position of popup relative to icon
    });

    // Player marker using Santa
    let playerMarker = L.marker(
      [LOCATIONS[0].lat, LOCATIONS[0].lng],
      { icon: santaIcon, title: "You" }
    ).addTo(map);


    // permanent zones
    const zoneCircles = new Array(LOCATIONS.length).fill(null);

    // temporary preview of "next zone"
    let tempZoneCircle = null;

    // show start immediately
    createStartZone();
    // progress bar to saved value
    updateProgress();

    // we only do the "rebuild previous zones" once per load
    let triedRecovery = false;

    if ("geolocation" in navigator) {
      navigator.geolocation.watchPosition(
        (pos) => {
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;
          const accuracy = pos.coords.accuracy;

          playerMarker.setLatLng([lat, lng]);
          document.getElementById("status").textContent =
            `You are here (accuracy ~${Math.round(accuracy)}m)`;

          if (!map._userMoved) map.setView([lat, lng]);

          // always try to rebuild on first fix
          if (!triedRecovery) {
            triedRecovery = true;
            tryRecoverProgressFromPosition(lat, lng);
          }

          checkProximity(lat, lng);
        },
        (err) => {
          console.error(err);
          document.getElementById("status").textContent =
            "Couldn't get your location. Make sure GPS is enabled and you're on HTTPS.";
        },
        { enableHighAccuracy: true, maximumAge: 5000, timeout: 8000 }
      );

      map.on("dragstart", () => { map._userMoved = true; });
    } else {
      alert("Geolocation is not supported in this browser.");
    }

    // try to ensure all previous zones are visible, AND detect if user is in a later zone
    function tryRecoverProgressFromPosition(lat, lng) {
      // 1) make zones from saved progress visible
      const lastSavedVisited = Math.max(0, currentIndex - 1);
      for (let i = 0; i <= lastSavedVisited; i++) {
        ensureZoneCircle(i, true);
      }

      // 2) see if the player is actually standing in a later zone than saved
      let lastReachedByPosition = -1;
      for (let i = 0; i < LOCATIONS.length; i++) {
        const loc = LOCATIONS[i];
        const dist = distanceInMeters(lat, lng, loc.lat, loc.lng);
        if (dist <= loc.radius) {
          lastReachedByPosition = i;
        }
      }

      // if the player is in a later zone than what was saved, upgrade progress
      if (lastReachedByPosition >= currentIndex) {
        for (let j = 0; j <= lastReachedByPosition; j++) {
          ensureZoneCircle(j, true);
        }
        currentIndex = lastReachedByPosition + 1;
        localStorage.setItem("huntProgress", currentIndex.toString());
        showHint(LOCATIONS[lastReachedByPosition]);
      }

      updateProgress();
    }

    function createStartZone() {
      const start = LOCATIONS[0];
      const circle = L.circle([start.lat, start.lng], {
        color: "#16a34a",
        fillColor: "#16a34a22",
        fillOpacity: 0.2,
        radius: start.radius
      })
      .addTo(map)
      .bindPopup("<b>Start</b>");
      circle.on("click", () => showHint(start));
      zoneCircles[0] = circle;
    }

    function checkProximity(userLat, userLng) {
      const target = LOCATIONS[currentIndex];
      if (!target) return;

      const dist = distanceInMeters(userLat, userLng, target.lat, target.lng);
      if (dist <= target.radius) {
        ensureZoneCircle(currentIndex, true);

        // remove temp preview if it was for this zone
        if (tempZoneCircle) {
          map.removeLayer(tempZoneCircle);
          tempZoneCircle = null;
          resetToggleButton();
        }

        showHint(target);
        currentIndex++;
        localStorage.setItem("huntProgress", currentIndex.toString());
        updateProgress();
      }
    }

    function ensureZoneCircle(index, visited = false) {
      if (index < 0 || index >= LOCATIONS.length) return;
      const loc = LOCATIONS[index];

      // Define your green tones
      const borderGreen = "#16a34a";   // solid border
      const fillGreen = "#16a34a80";   // 50% transparency (#RRGGBBAA form)

      if (zoneCircles[index]) {
        if (visited) {
          zoneCircles[index].setStyle({
            color: borderGreen,
            fillColor: fillGreen,
            fillOpacity: 0.5,
          });
        }
        return;
      }

      const circle = L.circle([loc.lat, loc.lng], {
        color: visited ? borderGreen : "#2563eb",
        fillColor: visited ? fillGreen : "#2563eb33",
        fillOpacity: visited ? 0.5 : 0.3,
        weight: 2,
        radius: loc.radius,
      })
      .addTo(map)
      .bindPopup(`<b>${loc.name}</b>`);

      circle.on("click", () => showHint(loc));
      zoneCircles[index] = circle;
    }


    // button: show/hide next zone
    function toggleNextZone() {
      const btn = document.getElementById("toggleZoneBtn");

      if (currentIndex >= LOCATIONS.length) {
        document.getElementById("status").textContent = "Hunt complete ðŸŽ‰";
        return;
      }

      // hide if already shown
      if (tempZoneCircle) {
        map.removeLayer(tempZoneCircle);
        tempZoneCircle = null;
        resetToggleButton();
        return;
      }

      // if it's already a permanent (visited) circle, just open it
      if (zoneCircles[currentIndex]) {
        zoneCircles[currentIndex].openPopup();
        return;
      }

      const target = LOCATIONS[currentIndex];
      tempZoneCircle = L.circle([target.lat, target.lng], {
        color: "#2563eb",
        fillColor: "#2563eb33",
        fillOpacity: 0.3,
        radius: target.radius
      })
      .addTo(map)
      .bindPopup(`<b>${target.name}</b>`);
      tempZoneCircle.on("click", () => showHint(target));
      map.setView([target.lat, target.lng], 17);
      tempZoneCircle.openPopup();

      btn.textContent = "Hide next zone";
    }

    function resetToggleButton() {
      const btn = document.getElementById("toggleZoneBtn");
      btn.textContent = "Show next zone";
    }

    function distanceInMeters(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const Ï†1 = lat1 * Math.PI/180;
      const Ï†2 = lat2 * Math.PI/180;
      const Î”Ï† = (lat2-lat1) * Math.PI/180;
      const Î”Î» = (lon2-lon1) * Math.PI/180;

      const a = Math.sin(Î”Ï†/2)**2 +
                Math.cos(Ï†1) * Math.cos(Ï†2) *
                Math.sin(Î”Î»/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function showHint(locationObj) {
      const box = document.getElementById("hintBox");
      document.getElementById("hintTitle").textContent = `Next stop: ${locationObj.name}`;
      document.getElementById("hintText").textContent = locationObj.hint;
      box.style.display = "block";
      document.getElementById("status").textContent = `Unlocked: ${locationObj.name}`;
    }

    function closeHint() {
      const box = document.getElementById("hintBox");
      box.style.display = "none";
      if (currentIndex >= LOCATIONS.length) {
        document.getElementById("status").textContent = "Hunt complete ðŸŽ‰";
      } else {
        document.getElementById("status").textContent =
          `Go to: ${LOCATIONS[currentIndex].name}`;
      }
    }

    function updateProgress() {
      const bar = document.getElementById("progressBar");
      const total = LOCATIONS.length;
      const completed = Math.min(currentIndex, total);
      bar.style.width = (completed / total) * 100 + "%";
    }

    // expose
    window.toggleNextZone = toggleNextZone;
    window.closeHint = closeHint;
  </script>
</body>
</html>
